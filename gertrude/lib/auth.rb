#!/usr/bin/env ruby
# Two Factor authentication module for gertrude.
# Maintains an 'auth' database in mongo, which contains, for each user,
# a salted password hash, and a list of yubikey crypto keys.
# To authenticate, a user needs their password and a registered physical key.
# Authentications are valid for some fixed period of time; once this expires,
# or if the bot restarts, users will have to re-authenticate.
#
# Email addrs. make better usernames than IRC nicks. (or use eg Nickserv
# validated nick).

require 'mongo'
require 'bcrypt'
require 'yubico'

# An authenticator class: for a given username (eg email address) require a password
# and compare it against the Bcrypted salted hash stored in the database.
# If :twofactor is true (default) also require a One Time Password as generated by
# a Yubikey (www.yubico.com) and authenticate that key against any yubico keys 
# registered to that user.
# Once authenticated, the session remains valid for :validity seconds (default is
# 10 mins).
# If the user logs out before then, you should call unauthenticate()
class Authenticator
    attr_reader :last_result, :validity, :two_factor
    def self.instance(opts = {})
        begin
            @@instance = Authenticator.new(opts)
            private_class_method :new
        rescue NoMethodError
            puts "Authenticator already instantiated"
        end
        return @@instance
    end
    def initialize(opts = {})
        options = {
            twofactor: true,
            validity:600,
            db: "gertrude",
            collection: "auths",
        }.merge(opts)

        @two_factor = options[:twofactor]
        @validity = options[:validity]
        @auth_users = {}
        @last_result = "NO_ERROR"

        @db = Mongo::Connection::new.db(options[:db])
        @collection = @db.collection(options[:collection])
    end

    # For any given unique ID, authenticate a user-provided username, password, 
    # and yubikey OTP.
    # ID is the caller's reference; username, password, and yubi details are
    # stored in the authentication database.
    def authenticate(id, username, password, otp)
        if r = @collection.find_one({ 'user' => username })
            if BCrypt::Password.new(r['hash']) == password
                return true unless @two_factor

                r['keys'].each do |y|
                    if (@last_result = Yubico.new(y[0], y[1]).verify(otp)) == Yubico::E_OK
                        @auth_users[id] = { username:username, time: Time.now }
                        return true
                    end
                end
            else
                @last_result = "BAD PASSWORD"
            end
        end
        false
    end

    def unauthenticate(id)
        @auth_users.delete(id)
    end

    def unauthenticate_user(username)
        @auth_users.delete_if {|k,v| v[:username] == username }
    end

    def authenticated?(id)
        if u = @auth_users[id]
            return true if(Time.now - u[:time]) <= @validity
        end
        false
    end

    def authenticated_user?(username)
        @auth_users.each_pair { |k,v| return true if authenticated?(k) }
    end
end

if __FILE__ == $0
    # test authentication: expects args to be [username] [password] [yubikey-OTP]
    a = Authenticator.instance()
    if a.authenticate('test', *ARGV)
        puts "**AUTHENTICATED**"
    else
        puts "**FAILED** (#{a.last_result})"
    end
end

